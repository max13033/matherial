<!DOCTYPE HTML>
<html>

<head>
<title>Заголовок страницы</title>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="http://localhost/test.ru/css/style.css">
</head>

<body>
<style type="text/css">


</style>

<form method="get">
	<label>Введите градусы</label><input type="text" name="faren">
	<input type="submit">
</form><br>


 Требования, предъявляемые к именам функций:

Имена функций могут содержать русские буквы, но давать функциям имена, состоящие из русских букв не рекоммендуется;
 Имена функций не должны содержать пробелов;
 Имя каждой пользовательской функции должно быть уникальным. При этом, необходимо помнить, 
 что регистр при объявлении функций и обращении к ним не учитывается. То есть, например, функции funct() и FUNCT() имеют одинаковые имена;
 Функциям можно давать такие же имена, как и переменным, только без знака $ в начале имен.

При программировании часто возникает необходимость создания функции с переменным числом параметров. Тому есть две причины:

Параметров слишком много. При этом нет смысла каждый раз указывать все параметры;
Функции должны возвращать значения разных типов в зависимости от набора параметров.
В PHP функции могут возвращать любые значения в зависимости от переданных им параметров.

<?
function makecup($type = "Чая")
{
     return "Сделайте чашечку $type.\n";
}
echo makecup();
echo makecup("Кофе");
?>

Результат работы приведенного скрипта будет таким:

Сделайте чашечку Чая
Сделайте чашечку Кофе

PHP также позволяет использовать массивы и специальный тип NULL в качестве значений по умолчанию, например:

<?php  
   function makecup($types = array("Кофе"), $Maker = NULL)  
   {  
       $device = is_null($Maker) ? "сахаром" : $Maker;  
       return "Сделайте чашечку ".join(", ", $types)." с $device.\n";  
   }  
   echo makecup();  
   echo makecup(array("Кофе", "Чая"), "сливками");  
  ?>

Рассмотренный скрипт выведет следующее:

Сделайте чашкчку Кофе с сахаром . Сделайте чашечку Кофе, Чая с сливками.

Значение по умолчанию должно быть константным выражением.

Обратите внимание, что все аргументы, для которых установлены значения по умолчанию, 
должны находится правее аргументов, для которых значения по умолчанию не заданы, 
в противном случае ваш код может работать не так, как вы этого ожидаете. 
Рассмотрим следующий пример:

<?php
function makecup($type = "чая", $cond)
{
     return "Сделайте чашечку $type $cond.\n";
}
  
echo makecup("горячего");   // Не будет работать так, как мы могли бы ожидать
?>

Результат работы приведенного выше скрипта будет примерно следующим:

Warning: Missing argument 2 for makecup() in c:\inetpub\php.su\test.php on line 2
Сделайте чашечку горячего .

Теперь видоизменим рассмотренный скрипт, исправив в нем ошибки:

<?php
function makecup($cond, $type = "чая")
{
     return "Сделайте чашечку $type $cond.\n";
}
  
echo makecup("горячего");   // Теперь наш скрипт работает корректно! 
?>

Результат работы исправленного скрипта будет выглядеть следующим образом:

Сделайте чашечку чая горячего.


Иногда мы точно не знаем, сколько параметров будет передано нашей функции. Специально для такого случая разработчики PHP предусмотрели возможность использования переменного числа аргументов.

Реализация этой возможности достаточно прозрачна и заключается в использовании функций func_num_args(), func_get_arg() и func_get_args().

Рассмотрим возможности рассмотренных стандартных функций:

Стандартная функция func_num_args() возвращает колличество аргументов, переданных пользовательской функции:

<?php
function funct() 
{
     $numargums = func_num_args();
     echo "Колличество аргументов : $numargums\n";
} 

funct(1, 2, 3);    // Скрипт выведет 'Колличество аргументов: 3'
?>

Стандартная функция func_get_arg() возвращает элемент из списка переданных пользовательской функции аргументов:

<?php
function funct() 
{
      $numargs = func_num_args();
      echo "Колличество аргументов: $numargs<br>\n";
      if ($numargs >= 2) {
      echo "Второй аргумент : ".func_get_arg(1)."<br>\n";
      }
} 

funct(1, 2, 3);
?>

Стандартная функция func_get_args() возвращает массив аргументов, переданных пользовательской функции:

<?php
function funct() 
{
     $numargs = func_num_args();
     echo "Колличество аргументов : $numargs<br>\n";
     if ($numargs >= 2) {
         echo "Второй аргумент: " . func_get_arg(1) . "<br>\n";
     }
     $arg_list = func_get_args();
     for ($i = 0; $i < $numargs; $i++) {
         echo "Аргумент $i is: " . $arg_list[$i] . "<br>\n";
     }
} 

funct(1, 2, 3);
?>

Обратите внимание, что при объявлении пользовательских функций в скобках мы ничего не пишем, то есть, как будто мы не передаем аргументы.


<?
if(isset($_GET['faren'])){
	$faren = $_GET['faren'];
	function faren_to_cel($argum){
		$cel = ($argum - 32)*5/9;
		// echo "$argum градусов по Фаренгейту - это $cel градусов цельсия";
		return $cel;
	}
	echo faren_to_cel($faren);


}

//Помимо локальных и глобальных переменных, в PHP существует еще один тип переменных - статические переменные.
//Если в теле пользовательской функции объявлена статическая переменная, то компилятор не будет ее удалять после завершения работы этой функции.
//Объявление статических переменных:

function funct(){
     static $int = 0;          // верно
     static $int = 1+2;        // неверно  (поскольку это выражение)
     static $int = sqrt(121);  // неверно  (поскольку это тоже выражение)

     $int++;
     echo $int;
}

//Пример работы пользовательской функции, содержащей статические переменные:

function funct()
   {
      static $a;
      $a++;
      echo "$a";
   }
   for ($i = 0; $i++<10;) funct();

// Данный сценарий выводит строку: 1 2 3 4 5 6 7 8 9 10
// Если мы удалим инструкцию static, будет выведена строка: 1 1 1 1 1 1 1 1 1 1
// Это связано с тем, что переменная $a будет удаляться при завершении работы функции и обнуляться при каждом ее вызове. 
// 	Переменная $a инкрементируется сразу после обнуления, а только потом выводится.

?>









</body>
</html>

