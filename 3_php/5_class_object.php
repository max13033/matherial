<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
</head>
<body>
	
Класс - это базовое понятие в объектно-ориентированном программировании (ООП). 
Классы образуют синтаксическую базу ООП. Их можно рассматривать как своего рода "контейнеры" 
для логически связанных данных и функций (обычно называемых методами — см. ниже). 
Если сказать проще, то класс - это своеобразный тип данных.

Экземпляр класса - это объект. Объект - это совокупность данных (свойств) и функций (методов) для их обработки. 
Свойства и методы называются членами класса. Вообще, объектом является все то, что поддерживает инкапсуляцию.

Если класс можно рассматривать как тип данных, то объект — как переменную (по аналогии). 
Скрипт может одновременно работать с несколькими объектами одного класса, как с несколькими переменными.

Внутри объекта данные и код (члены класса) могут быть либо открыты, либо нет. 
Открытые данные и члены класса являются доступными для других частей программы, 
которые не являются частью объекта. А вот закрытые данные и члены класса доступны только внутри этого объекта.

Описание классов в PHP начинаются служебным словом class:

class Имя_класса {
// описание членов класса - свойств и методов для их обработки
}

Для объявления объекта необходимо использовать оператор new:

Объект = new Имя_класса;

Данные описываются с помощью служебного слова var. Метод описывается так же, 
как и обыкновенная пользовательская функция. Методу также можно передавать параметры.

Подведем промежуточные итоги: объявление класса должно начинаться с ключевого слова 
class (подобно тому, как объявление функции начинается с ключевого слова function). 
Каждому объявлению свойства, содержащегося в классе, должно предшествовать ключевое слово var. 
Свойства могут относиться к любому типу данных, поддерживаемых в РНР, их можно рассматривать 
как переменные с небольшими различиями. После объявлений свойств следуют объявления методов, 
очень похожие на типичные объявления пользовательских функций.

По общепринятым правилам имена классов ООП начинаются с прописной буквы, а все слова в именах методов, 
кроме первого, начинаются с прописных букв (первое слово начинается со строчной буквы). 
Разумеется, вы можете использовать любые обозначения, которые сочтете удобными; 
главное — выберите стандарт и придерживайтесь его.

Пример класса на PHP:

<?php
// Создаем новый класс Coor:
class Coor {
// данные (свойства):
var $name;
var $addr;

// методы:
 function Name() {
 echo "<h3>John</h3>";
 }

}

// Создаем объект класса Coor:
$object = new Coor;
?>

Доступ к класам и объектам в PHP

Мы рассмотрели, каким образом описываются классы и создаются объекты. Теперь нам необходимо получить доступ к членам класса, для этого в PHP предназначен оператор ->. Приведем пример:

<?php
// Создаем новый класс Coor:
class Coor {
// данные (свойства):
var $name;

// методы:
 function Getname() {
 echo "<h3>John</h3>";
 }

}

// Создаем объект класса Coor:
$object = new Coor;
// Получаем доступ к членам класса:
$object->name = "Alex";
echo $object->name;
// Выводит 'Alex'
// А теперь получим доступ к методу класса (фактически, к функции внутри класса):
$object->Getname();
// Выводит 'John' заглавными буквами
?>

Чтобы получить доступ к членам класса внутри класса, необходимо использовать указатель $this, которы всегда относится к текущему объекту. Модифицированный метод Getname():

function Getname() {
echo $this->name;
}

Таким же образом, можно написать метод Setname():

function Setname($name) {
$this->name = $name;
}

Теперь для изменения имени можно использовать метод Setname():

$object->Setname("Peter"); 
$object->Getname();

А вот и полный листинг кода:

<?php
// Создаем новый класс Coor:
class Coor {
// данные (свойства):
var $name;

// методы:
 function Getname() {
 echo $this->name;
 }

 function Setname($name) {
 $this->name = $name;
 }

}

// Создаем объект класса Coor:
$object = new Coor;
// Теперь для изменения имени используем метод Setname():
$object->Setname("Nick");
// А для доступа, как и прежде, Getname():
$object->Getname();
// Сценарий выводит 'Nick'
?>

Указатель $this можно также использовать для доступа к методам, а не только для доступа к данным:

function Setname($name) {
$this->name = $name;
$this->Getname();
}

Конструкторы

Довольно часто при создании объекта требуется задать значения некоторых свойств. К счастью, разработчики технологии ООП учли это обстоятельство и реализовали его в концепции конструкторов. Конструктор представляет собой метод, который задает значения некоторых свойств (а также может вызывать другие методы). Конструкторы вызываются автоматически при создании новых объектов. Чтобы это стало возможным, имя метода-конструктора должно совпадать с именем класса, в котором он содержится. Пример конструктора:

<?
class Webpage {
var $bgcolor;
 function Webpage($color) {
 $this->bgcolor = $color;
 }
}

// Вызвать конструктор класса Webpage
$page = new Webpage("brown");
?>

Раньше создание объекта и инициализация свойств выполнялись раздельно. Конструкторы позволяют выполнить эти действия за один этап.

Интересная подробность: в зависимости от количества передаваемых параметров могут вызываться разные конструкторы. В рассмотренном примере объекты класса Webpage могут создаваться двумя способами. Во-первых, вы можете вызвать конструктор, который просто создает объект, но не инициализирует его свойства:

$page = new Webpage;

Во-вторых, объект можно создать при помощи конструктора, определенного в классе, — в этом случае вы создаете объект класса Webpage и присваиваете значение его свойству bgcolor:

$page = new Webpage("brown");

Деструкторы

В РНР отсутствует непосредственная поддержка деструкторов. Тем не менее, вы можете легко имитировать работу деструктора, вызывая функцию РНР unset(). Эта функция уничтожает содержимое переменной и возвращает занимаемые ею ресурсы системе. С объектами unset() работает так же, как и с переменными. Допустим, вы работаете с объектом $Webpage. После завершения работы с этим конкретным объектом вызывается функция:

unset($Webpage);

Эта команда удаляет из памяти все содержимое $Webpage. Действуя в духе инкапсуляции, можно поместить вызов unset() в метод с именем destroy() и затем вызвать его:

$Website->destroy();

Необходимость в вызове деструкторов возникает лишь при работе с объектами, использующими большой объем ресурсов, поскольку все переменные и объекты автоматически уничтожаются по завершении сценария.

Инициализация объектов

Иногда возникает необходимость выполнить инициализацию объекта - присвоить его свойствам первоначальные значения. Предположим, имя класса Coor и он содержит два свойства:имя человека и город его проживания. Можно написать метод (функцию), который будет выполнять инициализацию объекта, например Init():

<?php
// Создаем новый класс Coor:
class Coor {
// данные (свойства):
var $name;
var $city;

// Инициализирующий метод:
 function Init($name) {
 $this->name = $name;
 $this->city = "London";
 }

}

// Создаем объект класса Coor:
$object = new Coor;
// Для инициализации объекта сразу вызываем метод:
$object->Init();
?>

Главное не забыть вызвать функцию сразу после создания объекта, либо вызвать какой-нибудь метод между созданием (оператор new) объекта и его инициализацией (вызовом Init).

Для того, чтобы PHP знал, что определенный метод нужно вызывать автоматически при создании объекта, ему нужно дать имя такое же, как и у класса (Coor):

function Coor ($name)
$this->name = $name;
$this->city = "London";
}

Метод, инициализирующий объект, называется конструктором. Однако, PHP не имеет деструкторов, поскольку ресурсы освобождаюся автоматически при завершении работы скриптов.

Обращение к элементам классов

Обращение к элементам классов осуществляется с помощью оператора :: "двойное двоеточие". Используя "двойное двоеточие", можно обращаться к методам классов.

При обращении к методам классов, программист должен использовать имена этих классов.

<?php
class A {
     function example() {
         echo "Это первоначальная функция A::example().<br>";
     }
}

class B extends A {
     function example() {
         echo "Это переопределенная функция B::example().<br>";
         A::example();
     }
}

// Не нужно создавать объект класса A.
// Выводит следующее: 
// Это первоначальная функция A::example().
A::example();

// Создаем объект класса B.
$b = new B;

// Выводит следующее: 
//   Это переопределенная функция B::example().
//   Это первоначальная функция A::example().
$b->example();
?>


Используя этот оператор :: можно обращаться к константам, статическим или перегруженным свойствам или методам класса.

При обращении к этим элементам извне класса, программист должен использовать имя этого класса.

Обозначение "двойное двоеточие" (::) не менялось ни разу в течение всего времени разработки PHP.

Использование :: вне объявления класса

<?php
class MyClass {
   const CONST_VALUE = 'Значение константы';
}
echo MyClass::CONST_VALUE;
?>

Использование :: в объявлении класса

Для обращения к свойствам и методам в объявлении класса используются ключевые слова self и parent. Пример использования :: в объявлении класса:

<?php
class OtherClass extends MyClass {
   public static $my_static = 'статическая переменная';

   public static function doubleColon() {
      echo parent::CONST_VALUE . "\n";
      echo self::$my_static . "\n";
   }
}

OtherClass::doubleColon();
?>

Когда дочерний класс перегружает методы, объявленные в классе-родителе, PHP не будет осуществлять автоматический вызов методов, принадлежащих классу-родителю. Этот функционал возлагается на метод, перегружаемый в дочернем классе. Данное правило распространяется на конструкторы и деструкторы, перегруженные и другие методы.

Обращение к методу в родительском классе

<?php
class MyClass {

   protected function myFunc() {
     echo "MyClass::myFunc()\n";
   }
}

class OtherClass extends MyClass {

   /* Override parent's definition */
   public function myFunc() {

     /* But still call the parent function */
     parent::myFunc();
     echo "OtherClass::myFunc()\n";
   }
}

$class = new OtherClass();
$class->myFunc();
?>


</body>
</html>