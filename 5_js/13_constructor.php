<!DOCTYPE HTML>
<html>

<head>
<title>Заголовок страницы</title>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="http://localhost/test.ru/css/style.css">
</head>

<body>
<style type="text/css">


</style>
<script type="text/javascript">

//	Чтобы определить собственный конструктор, достаточно написать функцию, добавляющую новые свойства к объекту, на который ссылается ключевое слово this.
// Определяем конструктор.
// Обратите внимание, как инициализируется объект с помощью "this".
function Rectangle(w, h) {
this.width = w;
this.height = h;
}
// Вызываем конструктор для создания двух объектов Rectangle. Мы передаем ширину и высоту
// конструктору, чтобы можно было правильно проинициализировать оба новых объекта.
var rect1 = new Rectangle(2, 4); // rect1 = { width:2, height:4 };
var rect2 = new Rectangle(8.5, 11); // rect2 = { width:8.5, height:11 };

//	Предположим, что необходимо рассчитать площадь прямоугольника, представленного объектом Rectangle. Вот один из возможных способов:
function computeAreaOfRectangle(r) { return r.width * r.height; }

//	Эта функция прекрасно справляется с возложенными на нее задачами, но она не является объектно ориентированной. Работая с объектом, лучше всего вызывать
//	методы этого объекта, а не передавать объекты посторонним функциям в качестве аргументов. Этот подход демонстрируется в следующем фрагменте:
// Создать объект Rectangle
var r = new Rectangle(8.5, 11);
// Добавить к объекту метод
r.area = function() { return this.width * this.height; }
// Теперь рассчитать площадь, вызвав метод объекта
var a = r.area();
//	Конечно же, не совсем удобно добавлять новый метод к объекту перед его использованием. Однако ситуацию можно улучшить, если инициализировать
//	свойство area в функции-конструкторе. Вот как выглядит улучшенная реализация конструктора Rectangle():
function Rectangle(w, h) {
	this.width = w;
	this.height = h;
	this.area = function( ) { return this.width * this.height; }
}
//	С новой версией конструктора тот же самый алгоритм можно реализовать по-другому:
// Найти площадь листа бумаги формата U.S. Letter в квадратных дюймах
var r = new Rectangle(8.5, 11);
var a = r.area();

//	Прототипом объекта является значение свойства prototypeфункции-конструктора. Все функции имеют свойство prototype, которое инициализируется 
//	в момент определения функции. Начальным значением этого свойства является объект с единственным свойством. Это свойство называется
//	constructor и значением его является ссылка на саму функцию-конструктор, с которой этот прототип ассоциируется.

// Функция-конструктор инициализирует те свойства, которые могут иметь уникальные значения для каждого отдельного экземпляра.
function Rectangle(w, h) {
	this.width = w;
	this.height = h;
}
// Прототип объекта содержит методы и другие свойства, которые должны
// совместно использоваться всеми экземплярами этого класса.
Rectangle.prototype.area = function() { return this.width * this.height; }

//Унаследованные свойства ничем не отличаются от обычных свойств объекта.
//Они поддаются перечислению в цикле for/in и могут проверяться с помощью опе
//ратора in. Отличить их можно только с помощью метода Object.hasOwnProperty():
var r = new Rectangle(2, 3);
r.hasOwnProperty("width"); // true: width – непосредственное свойство "r"
r.hasOwnProperty("area"); // false: area – унаследованное свойство "r"
"area" in r; // true: area – свойство объекта "r"






</script>


<? 



?>









</body>
</html>

