<!DOCTYPE HTML>
<html>

<head>
<title>Заголовок страницы</title>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="http://localhost/test.ru/css/style.css">
</head>

<body>
<style type="text/css">


</style>
<script type="text/javascript">

Еслифункция-конструктор Positioned-
Rectangle() должна явно вызывать функцию-конструктор надкласса. Это назы-
вается вызовом конструктора по цепочке и является обычной практикой при
создании подклассов. Вы можете упростить синтаксис конструктора, добавив
свойство superclass в объект-прототип подкласса:
// Сохранить ссылку на конструктор надкласса.
PositionedRectangle.prototype.superclass = Rectangle;

После того как свойство определено, синтаксис вызова конструктора по цепочке
становится значительно проще:
function PositionedRectangle(x, y, w, h) {
this.superclass(w,h);
this.x = x;
this.y = y;
}
Обратите внимание: функция-конструктор явно вызывается в контексте объек-
та this. Это означает, что можно отказаться от использования метода call() или
apply() для вызова конструктора надкласса как метода данного объекта.

Предположим, что класс Rectangle определяет
метод toString() (что должно быть сделано чуть ли не в первую очередь) следую-
щим образом:
186 Глава 9. Классы, конструкторы и прототипы
Rectangle.prototype.toString = function( ) {
return "[" + this.width + "," + this.height + "]";
}
Если уж вы реализовали метод toString() в классе Rectangle, то тем более его не-
обходимо переопределить в классе PositionedRectangle, чтобы экземпляры под-
класса могли иметь строковое представление, отражающее значения не только
ширины и высоты, но и всех остальных их свойств. PositionedRectangle – очень
простой класс и для него достаточно, чтобы метод toString() просто возвращал
значения всех его свойств. Однако ради примера будем обрабатывать значения
свойств координат в самом классе, а обработку свойств width и height делегируем
надклассу. Сделать это можно примерно следующим образом:
PositionedRectangle.prototype.toString = function() {
return "(" + this.x + "," + this.y + ") " + // поля этого класса
Rectangle.prototype.toString.apply(this); // вызов надкласса по цепочке
}
Реализация метода toString() надкласса доступна как свойство объекта-прото-
типа надкласса. Обратите внимание: мы не можем вызвать метод напрямую –
нам пришлось воспользоваться методом apply(), чтобы указать, для какого объ-
екта вызывается метод.
Однако если в PositionedRectangle.prototype добавить свойство superclass, можно
сделать так, чтобы этот код не зависел от типа надкласса:
PositionedRectangle.prototype.toString = function( ) {
return "(" + this.x + "," + this.y + ") " + // поля этого класса
this.superclass.prototype.toString.apply(this);
}
Еще раз обратите внимание, что свойство superclass может использоваться в ие-
рархии наследования только один раз. Если оно будет задействовано классом
и его подклассом, это приведет к бесконечной рекурсии.


</script>









</body>
</html>

