<!DOCTYPE HTML>
<html>

<head>
<title>Заголовок страницы</title>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="http://localhost/test.ru/css/style.css">
</head>

<body>
<style type="text/css">


</style>
<script type="text/javascript">

//	Массив – это тип данных, содержащий (хранящий) пронумерованные значения.
//	Каждое пронумерованное значение называется элементом массива, а число, с которым связывается элемент, называется его индексом.

var empty = []; // Пустой массив
var primes = [2, 3, 5, 7, 11]; // Массив с пятью числовыми элементами
var misc = [ 1.1, true, "a" ]; // 3 элемента разных типов
//	либо так:
var a = new Array( );  //  пустой массив
var a = new Array(5, 4, 3, 2, 1, "testing, testing");

//	Вызов с единственным числовым аргументом, определяющим длину массива:
var a = new Array(10);

Обратите внимание: элементы массива могут также добавляться к объектам:
var c = new Circle(1,2,3);
c[0] = "это элемент массива в объекте!"
// Этот пример просто определяет новое свойство объекта с именем "0". Однако добавление элемента массива в объект не делает объект массивом.

// Оператор delete записывает в элемент массива значение undefined, при этом сам
// элемент массива продолжает свое существование. Для удаления элементов так,
// чтобы остающиеся элементы сместились к началу массива, необходимо воспользоваться 
// одним из методов массива. Метод Array.shift() удаляет первый элемент
// массива, метод Array.pop() – последний элемент массива, метод Array.splice() –
// непрерывный диапазон элементов.

// Свойство length массива доступно как для чтения, так и для записи. Если установить свойство length в значение, меньшее текущего, 
// массив укорачивается до новой длины; любые элементы, не попадающие в новый диапазон индексов, отбрасываются, и их значения теряются.

//	"Многомерный" массив
// Создать многомерный массив
var table = new Array(10); // В таблице 10 строк
for(var i = 0; i < table.length; i++)
	table[i] = new Array(10); // В каждой строке 10 столбцов
	// Инициализация массива
	for(var row = 0; row < table.length; row++) {
		for(col = 0; col < table[row].length; col++) {
			table[row][col] = row*col;
		}
	}

// Метод Array.join() преобразует все элементы массива в строки и объединяет их. Можно указать необязательный строковый аргумент, предназначенный для 
// разделения элементов в результирующей строке. Если разделитель не задан, используется запятая. Например, следующий фрагмент дает в результате строку "1,2,3":
var a = [1, 2, 3]; // Создает новый массив с указанными тремя элементами
var s = a.join(); // s == "1,2,3"
//	В следующем примере задается необязательный разделитель, что приводит к несколько иному результату:
s = a.join(", "); // s == "1, 2, 3"

//	Метод Array.reverse() меняет порядок следования элементов в массиве на противоположный и возвращает массив с переставленными элементами.
var a = new Array(1,2,3); // a[0] = 1, a[1] = 2, a[2] = 3
a.reverse(); // теперь a[0] = 3, a[1] = 2, a[2] = 1
var s = a.join(); // s == "3,2,1"

//	Метод Array.sort() на месте сортирует элементы массива и возвращает отсортированный массив. Если метод sort() вызывается без аргументов, то он сортирует
//	элементы массива в алфавитном порядке (при необходимости временно преобразуя их в строки для выполнения сравнения):
var a = new Array("banana", "cherry", "apple");
a.sort();
var s = a.join(", "); // s == "apple, banana, cherry"    Неопределенные элементы переносятся в конец массива.

//	Метод Array.concat() создает и возвращает новый массив, содержащий элементы исходного массива, для которого был вызван метод concat(), последовательно 
//	дополненный значениями всех аргументов, переданных методу concat(). Если какой-либо из этих аргументов сам является массивом, в результирующий массив
//	добавляются его элементы. Однако обратите внимание, что рекурсивного разделения массивов из массивов не происходит. Вот несколько примеров:
var a = [1,2,3];
a.concat(4, 5) // Возвращает [1,2,3,4,5]
a.concat([4,5]); // Возвращает [1,2,3,4,5]
a.concat([4,5],[6,7]) // Возвращает [1,2,3,4,5,6,7]
a.concat(4, [5,[6,7]]) // Возвращает [1,2,3,4,5,[6,7]]

//	Метод Array.slice() возвращает фрагмент, или подмассив, указанного массива. Два аргумента метода определяют начало и конец возвращаемого фрагмента.
//	звращаемый массив содержит элемент, номер которого указан в качестве первого аргумента, плюс все последующие элементы, вплоть до (но не включая) 
//	элемента, номер которого указан во втором аргументе. Если указан только один аргумент, возвращаемый массив содержит все элементы от начальной позиции до
//	конца массива. Если какой-либо из аргументов отрицателен, он задает номер элемента массива относительно конца массива. Так, аргумент, равный –1, задает
//	последний элемент массива, а аргумент, равный –3, – третий элемент массива с конца. Вот несколько примеров:
var a = [1,2,3,4,5];
a.slice(0,3); // Возвращает [1,2,3]
a.slice(3); // Возвращает [4,5]
a.slice(1,-1); // Возвращает [2,3,4]
a.slice(-3,-2); // Возвращает [3]

//	Метод Array.splice() – это универсальный метод для вставки или удаления элементов массива.
//	Первый аргумент splice() задает позицию в массиве, с которой начинается вставка и/или удаление. Второй аргумент задает количество элементов, 
//	которые должны быть удалены (вырезаны) из массива. Если второй аргумент опущен, удаляются все элементы массива от начального до конца массива. 
//	Метод splice() возвращает массив удаленных элементов или (если ни один из элементов не был удален) пустой массив. Например:
var a = [1,2,3,4,5,6,7,8];
a.splice(4); // Возвращает [5,6,7,8]; a равно [1,2,3,4]
a.splice(1,2); // Возвращает [2,3]; a равно [1,4]
a.splice(1,1); // Возвращает [4]; a равно [1]

//	Первые два аргумента splice() задают элементы массива, подлежащие удалению. За этими аргументами может следовать любое количество дополнительных
//	аргументов, задающих элементы, которые будут вставлены в массив, начиная с позиции, заданной первым аргументом. Например:
var a = [1,2,3,4,5];
a.splice(2,0,'a','b'); // Возвращает []; a равно [1,2,'a','b',3,4,5]
a.splice(2,2,[1,2],3); // Возвращает ['a','b']; a равно [1,2,[1,2],3,3,4,5]
//	Обратите внимание, что, в отличие от concat(), метод splice() не разбивает на отдельные элементы вставляемые аргументы-массивы. 
//	То есть если методу передается массив для вставки, он вставляет сам массив, а не элементы этого массива.

//	Методы push() и pop() позволяют работать с массивами как со стеками. Метод push() добавляет один или несколько новых элементов в конец массива и 
//	возвращает его новую длину. Метод pop() выполняет обратную операцию – удаляет последний элемент массива, уменьшает длину массива и возвращает удаленное им
//	значение. Обратите внимание: оба эти метода изменяют массив на месте, а не создают его модифицированную копию. Комбинация push() и pop() позволяет
//	в JavaScript с помощью массива реализовать стек с дисциплиной обслуживания «первым вошел – последним вышел». Например:
var stack = []; // стек: []
stack.push(1,2); // стек: [1,2] Возвращает 2
stack.pop(); // стек: [1] Возвращает 2
stack.push(3); // стек: [1,3] Возвращает 2
stack.pop(); // стек: [1] Возвращает 3
stack.push([4,5]); // стек: [1,[4,5]] Возвращает 2
stack.pop() // стек: [1] Возвращает [4,5]
stack.pop(); // стек: [] Возвращает 1

//	Методы unshift() и shift() ведут себя во многом так же, как push() и pop(), за исключением того, что они вставляют и удаляют элементы в начале массива, а не
//	в его конце. Метод unshift() смещает существующие элементы в сторону больших индексов для освобождения места, добавляет элемент или элементы в 
//	начало массива и возвращает новую длину массива. Метод shift() удаляет и возвращает первый элемент массива, смещая все последующие элементы вперед 
//	на одну позицию для занятия свободного места в начале массива. Например:
var a = []; // a:[]
a.unshift(1); // a:[1] Возвращает: 1
a.unshift(22); // a:[22,1] Возвращает: 2
a.shift(); // a:[1] Возвращает: 22
a.unshift(3,[4,5]); // a:[3,[4,5],1] Возвращает: 3
a.shift(); // a:[[4,5],1] Возвращает: 3
a.shift(); // a:[1] Возвращает: [4,5]
a.shift(); // a:[] Возвращает: 1
//	Обратите внимание на поведение метода unshift() при вызове с несколькими аргументами. Аргументы вставляются не по одному, а все сразу (как в случае 
//	с ме тодом splice()). Это значит, что в результирующем массиве они будут следовать в том же порядке, в котором были указаны в списке аргументов. 
//	Будучи вставленными по одному, они бы расположились в обратном порядке.










</script>


<? 



?>









</body>
</html>

