<!DOCTYPE HTML>
<html>

<head>
<title>Заголовок страницы</title>
<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="http://localhost/test.ru/css/style.css">
</head>

<body>
<style type="text/css">


</style>
<script type="text/javascript">

//	JavaScript позволяет определять функции в виде функциональных литералов. Как говорилось в главе 3, функциональный литерал – это выражение, определяющее неименованную функцию. 
//	Синтаксис функционального литерала во многом напоминает синтаксис инструкции function, за исключением того, что он используется как выражение, 
//	а не как инструкция, и ему не требуется имя функции. Следующие две строки кода определяют две более или менее идентичные функции с помощью инструкции function и функционального литерала:
// !!! Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.

function f(x) { return x*x; } // инструкция function,  её можно вызывать даже до объявления !!!

var f = function(x) { return x*x; }; // функциональный литерал Функциональные литералы создают неименованные функции, но синтаксис допускает указание имени функции, 
//	что может пригодиться при написании рекурсивных функций, вызывающих самих себя. Например:
var f = function fact(x) { if (x <= 1) return 1; else return x*fact(x - 1); };
//	Эта строка кода определяет неименованную функцию и сохраняет ссылку на нее в переменной f. Она на самом деле не создает функцию с именем fact, но позволяет 
//	телу функции ссылаться с помощью этого имени на саму себя. 

//														====================	arguments 		=============

//	Объект Arguments – это нечто вроде массива, позволяющего извлекать переданные функции значения по номеру, а не по имени.
//	Предположим, что была определена функция f, которая требует один аргумент, x. Если вызвать эту функцию с двумя аргументами,
//	то первый будет доступен в функции по имени параметра x или как arguments[0]. Второй аргумент доступен только как arguments[1]. 
//	Кроме того, как и у всех массивов, у arguments имеется свойство length, указывающее на количество содержащихся в массиве элементов.

function f(x, y, z){
	// Сначала проверяется, правильное ли количество аргументов передано
	if (arguments.length != 3) {
		throw new Error("функция f вызвана с " + arguments.length + "аргументами, а требуется 3.");
	}
	// А теперь сам код функции...
}

function f(x) {
	print(x); // Выводит начальное значение аргумента
	arguments[0] = null; // Изменяя элементы массива, мы также изменяем x
	print(x); // Теперь выводит "null"
}

//	Помимо элементов своего массива объект Arguments определяет свойство callee, ссылающееся на исполняемую в данный момент функцию. Его можно 
//	использовать, например, для рекурсивного вызова неименованных функций. Вот пример неименованного функционального литерала, вычисляющего факториал:

function(x) {
	if (x <= 1) return 1;
	return x * arguments.callee(x - 1);
}

//  функции-стрелки:
// была простая анонимная функция 
var inc = function (x) { return x+1; } 

// стала запись в одну строчку 
var inc = x => x+1;

// была функция с несколькими аргументами 
var sum = function (a, b) { return a+b; } 

// стала запись в одну строчку 
var sum = (a, b) => a+b;


//												=============	Использование свойств объекта в качестве аргументов		=======================
function easycopy(args) {
	arraycopy(args.from,
	args.from_start || 0, // Обратите внимание, как назначаются значения по умолчанию
	args.to,
	args.to_start || 0,
	args.length);
}
// Далее следует пример вызова функции easycopy():

var a = [1,2,3,4];
var b = new Array(4);
easycopy({from: a, to: b, length: 4});

//											===================		Функция как элемент массива		===================
var a = new Array(3);
a[0] = function(x) { return x*x; }
a[1] = 20;
a[2] = a[0](a[1]); // a[2] содержит 400

//											================	 Передача функции как данных		===================

function operate(operator, operand1, operand2)
{
return operator(operand1, operand2);
}
// Вот так можно вызвать эту функцию для вычисления значения выражения (2+3) + (4*5):

var i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5));
// Ради примера, мы реализуем эти функции снова, на этот раз с помощью функциональных литералов внутри литерала объекта.

var operators = {
	add: function(x,y) { return x+y; },
	subtract: function(x,y) { return x-y; },
	multiply: function(x,y) { return x*y; },
	divide: function(x,y) { return x/y; },
	pow: Math.pow // Для предопределенных функций это тоже работает
};
// Эта функция принимает имя оператора, отыскивает оператор в объекте,
// а затем вызывает его для переданных операндов. Обратите внимание
// на синтаксис вызова функции оператора.

function operate2(op_name, operand1, operand2){
	if (typeof operators[op_name] == "function")
	return operators[op_name](operand1, operand2);
	else throw "неизвестный оператор";
}
//											==========================	this  =============================

//	Методы обладают одним очень важным свойством: объект, посредством которого вызывается метод, становится значением ключевого слова this в теле метода.
//	То есть когда вызывается метод o.m(), в теле метода можно получить доступ к объекту o с помощью ключевого слова this. 
var calculator = { // Литерал объекта
	operand1: 1,
	operand2: 1,
	compute: function( ) {
				this.result = this.operand1 + this.operand2;
			}
};
calculator.compute(); // Сколько будет 1+1?
print(calculator.result); // Выводит результат

//									================================ 	length 	==============================

//	В следующем фрагменте определяется функция с именем check(), получающая массив аргументов от другой функции. Она сравнивает свойство arguments.length
//	со свойством Function.length (доступным как arguments.callee.length) и проверяет, передано ли функции столько аргументов, сколько она ожидает. Если это не
//	так, генерируется исключение. За функцией check() следует тестовая функция f(), демонстрирующая порядок вызова функции check():

function check(args) {
	var actual = args.length; // Фактическое число аргументов
	var expected = args.callee.length; // Ожидаемое число аргументов
	if (actual != expected) { // Если числа не совпадают, генерируется исключение
		throw new Error("неверное число аргументов: ожидается: " + expected + "; фактически передано " + actual);
	}
}
function f(x, y, z) {
	// Проверяем, соответствует ли ожидаемому фактическое количество аргументов. Если не соответствует, генерируем исключение
	check(arguments);
	// Теперь выполняем оставшуюся часть функции обычным образом
	return x + y + z;
}

// 								============================		Свойство объекта "Function" 	==================

// Создаем и инициализируем "статическую" переменную. Объявления функций обрабатываются до исполнения кода,
// поэтому мы действительно можем выполнить это присваивание до объявления функции
uniqueInteger.counter = 0;
// Сама функция. Она возвращает разные значения при каждом вызове и использует собственное "статическое" свойство
// для отслеживания последнего возвращенного значения.
function uniqueInteger() {
// Наращиваем и возвращаем значение "статической" переменной
return uniqueInteger.counter++;
}

//											=====================			call() и apply().	=================

//	Эти методы позволяют вызывать функцию так, будто она является методом некоторого объекта. Первый аргумент методов call() и apply() – это объект, для
//	которого выполняется функция; этот аргумент становится значением ключевого слова this в теле функции. Все оставшиеся аргументы call() – это значения, 
//	передаваемые вызываемой функции. Так, чтобы передать функции f() два числа и вызвать ее как метод объекта o, можно использовать следующий прием:

f.call(o, 1, 2);
//	Это аналогично следующим строкам программы:

o.m = f;
o.m(1,2);
delete o.m;

//	Метод apply() похож на метод call(), за исключением того, что передаваемые функции аргументы задаются в виде массива:
f.apply(o, [1,2]);

//	Например, чтобы найти наибольшее число в массиве чисел, можно вызвать метод apply() для передачи элементов массива функции Math.max():
var biggest = Math.max.apply(null, array_of_numbers);
</script>


<? 



?>









</body>
</html>

